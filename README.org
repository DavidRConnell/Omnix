#+TITLE: Omnix

The aim of this package is to make it easier to write technical documents in org-mode without relying on backend specific logic that makes it difficult to export to other output file types.
Many high-level document generation functions (like managing acronyms, context-specific referencing, coloring text) are not directly supported in Org mode.
These means either hardcoding acronyms and cross-referencing values (error-prone) or adding in backend specific logic that makes the document more tedious to write and harder to export to multiple backends.
Like ~org-cite~ did to citation management, ~Omnix~ intends to do to some other features that are supported through third-party LaTeX packages.

The primary focus is writing the logic of some common LaTeX packages in emacs-lisp and providing new org-mode links and macros for them.
This can be used to simplify exporting to multiple backends and to generate a tex file that only depends on basic LaTeX packages typically allowed by journals while continuing to let the computer manage tedious and error prone tasks.

For instance, the ~glossaries~ LaTeX package manages acronyms for you, automatically printing the full form on the first use and just the acronym for the remaining uses.
The ~omnix-acronym~ will provide this same functionality but from within the exporter, so it will work for all backends and will produce a tex file that doesn't depend on the ~glossaries~ package, which many journals don't allow.

This package does not intend on fully porting the LaTeX packages it supports.
Rather the goal is to produce an incrementally larger set of functionality as needed to produce files.

* Basic usage
With the package location added to your ~load-path~, you can load it with the usual ~require~:

#+begin_src elisp
  (add-to-list 'load-path "path/to/package/root")
  (require 'omnix)
#+end_src

** CAPFs
Omnix provides a completion at point function (CAPF) for some link types.
This can be turned on by adding the relevant setup functions to `org-mode-hook`.

#+begin_src elisp
  (add-hook 'org-mode-hook #'omnix-capf-setup)
#+end_src

The capf function also adds completion for general org link type name completion.
For example if point is in a link but before a ":" separator, this will provide candidates for link types.

* Design principles
** Papers
~Omnix~ defines papers based on ~#+INCLUDE:~ macros.
For a single file paper, the paper is defined as only the one Org file, but for multiple files, ~Omnix~ will search for a paper root than scan each file included by the paper recursively until it builds a list of all Org files downstream of the root file.
This allows ~Omnix~ to provide completion for values defined elsewhere in the paper.
~Omnix~ can handle a project with a single paper spread across multiple Org files or a project that contains many single file papers (or even a project with multiple multi-file papers).
The provided ~capf~ functions attempt to be smart about when to search files but if a cache ever gets out of date the ~omnix-search-clear-caches~ function can be called to force rebuilding the cache (if caches consistently go stale, please open an issue).

In the case where a single Org file is included by multiple Org files, this will be considered the root file.
While this isn't a true root file, the idea is if a file has been included by multiple files above it, it is not safe to use values defined in a file above it.

** Processors
Inspired by ~org-cite~'s use of a citation processor, ~Omnix~ relies on processors to perform the specific transformation whenever there are multiple ways to handle a function.
This allows users to set an alist associating backends with preferred processors.
Generally, when processors are used, there will be a ~plain~ processor which performs pure text transformations.
This ensures that the processor is backend independent.
More sophisticated processors can then be specific to a backend or a set of backends.
Given that the features provided by ~Omnix~, tend to be based on LaTeX packages, there will often be a processor named after the LaTeX package it was derived from (such as the ~gls~ acronym processor).
These processors will be LaTeX (and derived) backend specific and will defer processing to the LaTeX package.

When processors are used, there will be a global variable that can be edited to set the default processors to use (~omnix-*-processor-alist~, where ~*~ is a wildcard for the specific module).
The processor can also be set at the buffer level with a keyword:

#+begin_src org
  ,#+OMNIX_ACRONYM_PROCESSOR: latex:gls link
#+end_src

To set a processor for a specific backend, use the ~backend:processor~ notation.
When processor is set on it's own, that will be used for any backend that does was not explicitly given a processor.

To simplify generating output files that depend only on standard packages, there is a ~omnix-plain~ option.
When this is set to true in a buffer, only plain processors will be used and some other features that depend on non-standard packages will be disabled:

#+begin_src org
  ,#+OPTIONS: omnix-plain:t
#+end_src

See the test Org files to get a quick view of common usage.
* Acronyms
The ~omnix-acronym~ module provides features similar to the ~glossaries~ LaTeX package.
This provides four new link types for managing acronyms: ~acr~, ~acr/short~, ~acr/long~, and ~acr/full~.
The ~acr~ links is the primary link type, this will expand to the full form the first time the acronym is written, otherwise it will be printed as the acronym.
This removes the need of tracking where you first used an acronym when you edit your draft.
The other link types will always print the short, long, or full forms respectively.
For the acronym "GUI", the short form is the acronym itself "GUI", the long form is written out "Graphical User Interface", and the full form is the definition of the acronym "Graphical User Interface (GUI)."

To use acronyms, they must be defined user Org keywords in the form ~key:short:long~, where ~key~ is what is used to identify the acronym in the links.
As a full example:

#+begin_src org
  ,#+OMNIX_ACRONYM: gui:GUI:Graphical User Interface
  ,#+OMNIX_ACRONYM: tui:TUI:Text User Interface
  ,#+OMNIX_ACRONYM: cli:CLI:Command-Line Interface

  The application's behavior can be modified by passing arguments to the [[acr:cli]] (expands to full form) or by configuration with its [[acr:gui]] (also expands to full form).
  When using the [[acr:cli]] (expands to "CLI"), ...
  As opposed to a [[acr:gui]], a [[acr/long:tui]] (expands to "Text User Interface")...
#+end_src

Note: Acronym must be defined one per keyword.

This module currently has three processors, ~plain~, ~link~, and ~gls~.
The ~link~ processor will link later ~[[acr:key]]~ links to the first use (i.e. the definition).
It only creates hyperlinks for the ~acr~ links.
This can be used with any backend that has hyperlink functions defined for it in the ~omnix-hyperlink.el~ file.

The ~gls~ processor defers acronym management to the ~glossaries~ package and therefore only works with LaTeX derived backends.
* Text coloring
Color links allow coloring text for different backends.
This adds the ~xcolor~ package as a dependency for LaTeX backends.
Naturally, text coloring does not work with plain text backends.
For those a fallback method is used based on the format string in ~omnix-color-fallback~.
This uses a special format string where ~%s~ will be replaced with the link description and ~%c~ will be replaced with the color name (not the color code).
Either format argument can be omitted.

Basic usage:

#+begin_src org
  [[color:red][An important message]]
#+end_src

Colors can be defined in the header with keyword ~#+OMNIX_COLOR: blue:#0071BC~ or globally in the ~omnix-color-alist~.
Currently only HTML color codes are supported.

If a color that has not be defined is used, that color will be passed as is to the backend.
For example, assuming blue is defined as above, ~[[color:blue][Some colorful text]]~ will be passed to HTML as ~<a style="color:#0071BC;">Some colorful text</a>~ whereas if "red" has not been defined the previous example would be transcoded to ~<a style="color:red;">An important message</a>~ allowing the use of predefined colors (but note the potential for backends to not have the same list of predefined colors).

Colors can also be mixed using syntax taken from LaTeX's ~xcolor~ package, ~name:color1!percent!color2~ or ~name:color1,nparts1;color2,nparts2;...~:

#+begin_src org
  ,#+OMNIX_COLOR: gray:black!30
  ,#+OMNIX_COLOR: darkblue:blue!70!black
  ,#+OMNIX_COLOR: purple:red,1;blue,1.5
#+end_src

The first syntax mixes a color that is ~percent%~ ~color1~ and ~(100 - percent)%~ ~color2~.
When the second color is omitted, it defaults to white.
The second syntax generates a color made by combining different ratios of previously defined colors, so ~purple~ above is made by mixing 1 part red with 1.5 parts blue.

Note that color-mixing is performed by Emacs for HTML backends.
This means you could get unexpected results when mixing with predefined colors.
For example, if in Org you use the predefined color "red", that will directly get passed to HTML, but the mixed color ~lightred:red!70~ will be calculated in Emacs and the resulting hex color code will be written to the HTML output.
If "red" is defined differently between Emacs and the CSS class, "lightred" may not be a proper tint of "red".
To avoid this, "red" can be explicitly defined in Org.
Alternatively, it may be possible to define colors using the CSS ~color-mix~.

* Sansext links
The ~sansext~ links are transformed into regular ~file~ links after replacing the path's extension with the backend preferred extension (as defined in ~omnix-sansext-extension-alist~).
These links are intended to be used with images, and likely images that are pragmatically generated, to dynamically select the best image type for the backend.
By default, LaTeX will use PDFs, HTML (and derived backends including markdown) will use SVGs, and everything else uses PNGs.
No attempt at being clever in the selection process is made, the links are blindly converted, if there is no file with the selected extension the export fail.

As an example, if this PNG ~sansext~ link is in the Org file ~[[sansext:lines.png]]~, it will be translated to ~[[file:lines.pdf]]~ when exporting to PDF and to ~[[file:lines.svg]]~ when exporting to HTML.
(Note the extension is optional ~[[sansext:lines]]~ would work as well.)
See the ~tests/Makefile~ for an example of a ~make~ recipe that ensures the output is dependent on the generation of the right figures.

* Extending
Whenever a module uses processors, users can create new processors with the ~omnix-*-create-processor~ functions.
Those can then be added to the relevant processor alist.
Processors are plists with at a minimum a name and an optional backend list when it is specific to one or more backends and an optional setup function (see ~omnix--processors.el~ for more information on the generic processor interface).

Modules will extend that interface to require a set of functions for performing specific tasks.
Often this will mean a function per link that is handled.
See the creation functions help for the exact functions required.

* Tips
You can use Omnix's search functionality to provide paper-aware completion outside of Omnix.
As an example, the following function will wrap the ~citar~ citation completion to show candidates from paper specific bibliographies instead of the global ~citar-bibliography~.

#+begin_src emacs-lisp
  (defun my-citar-insert ()
      "Use citar to insert a citation but use the local bib file if available."
      (interactive)
      (let* ((bibs (mapcar (lambda (relpath)
  			   (expand-file-name relpath (projectile-project-root)))
  			 (omnix-search-get-candidates
  			  (omnix-search-keyword-re "BIBLIOGRAPHY" "\\(.*\\)"))))
  	   (citar-bibliography (or bibs citar-bibliography)))

        (call-interactively #'org-cite-insert)))
#+end_src
