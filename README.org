#+TITLE: Omnix

The aim of this package is to make it easier to write technical documents in org-mode without relying on backend specific logic that makes it difficult to export to other output file types.
Many high-level document generation functions (like managing acronyms, context-specific referencing, coloring text) are not directly supported in Org mode.
These means either hardcoding acronyms and cross-referencing values (error-prone) or adding in backend specific logic that makes the document more tedious to write and harder to export to multiple backends.
Like ~org-cite~ did to citation management, ~Omnix~ intends to do to some other features that are supported through third-party LaTeX packages.

The primary focus is writing the logic of some common LaTeX packages in emacs-lisp and providing new org-mode links and macros for them.
This can be used to simplify exporting to multiple backends and to generate a tex file that only depends on basic LaTeX packages typically allowed by journals while continuing to let the computer manage tedious and error prone tasks.

For instance, the ~glossaries~ LaTeX package manages acronyms for you, automatically printing the full form on the first use and just the acronym for the remaining uses.
The ~omnix-acronym~ will provide this same functionality but from within the exporter, so it will work for all backends and will produce a tex file that doesn't depend on the ~glossaries~ package, which many journals don't allow.

This package does not intend on fully porting the LaTeX packages it supports.
Rather the goal is to produce an incrementally larger set of functionality as needed to produce files.

* Basic usage
With the package location added to your ~load-path~, you can load it with the usual ~require~:

#+begin_src elisp
  (add-to-list 'load-path "path/to/package/root")
  (require 'omnix)
#+end_src

This will load the modules that do not have default side effects on outputs (specifically tex).
One of the goals of this package is to produce minimal tex files that can't be sent elsewhere to generate various other files, as such modules like ~omnix-color~ are not loaded by default as they will cause generated tex files to always load the ~xcolor~ package.
Other modules, such as ~omnix-acronym~, may add dependencies to tex files, but they only do so when either the default settings are changed or when their features are actually used and can therefore be safely loaded.
Instead, these modules can be loaded manually, or ~omnix~ makes a ~omnix-global~ function available which will load the remaining modules.

#+begin_src elisp
  (require 'omnix)
  (omnix-global)
#+end_src

* Design principles
Inspired by ~org-cite~'s use of a citation processor, ~Omnix~ relies on processors to perform the specific transformation whenever there are multiple ways to handle a function.
This allows users to set an alist associating backends with preferred processors.
Generally, when processors are used, there will be a ~plain~ processor which performs pure text transformations.
This ensures that the processor is backend independent.
More sophisticated processors can then be specific to a backend or a set of backends.
Given that the features provided by ~Omnix~, tend to be based on LaTeX packages, there will often be a processor named after the LaTeX package it was derived from (such as the ~gls~ acronym processor).
These processors will be LaTeX (and derived) backend specific and will defer processing to the LaTeX package.

When processors are used, there will be a global variable that can be edited to set the default processors to use (~omnix-*-processor-alist~, where ~*~ is a wildcard for the specific module).
The processor can also be set at the buffer level with a keyword:

#+begin_src org
  ,#+OMNIX_ACRONYM_PROCESSOR: latex:gls link
#+end_src

To set a processor for a specific backend, use the ~backend:processor~ notation.
When processor is set on it's own, that will be used for any backend that does was not explicitly given a processor.

See the test Org files to get a quick view of common usage.

* Acronyms
The ~omnix-acronym~ module provides features similar to the ~glossaries~ LaTeX package.
This provides four new link types for managing acronyms: ~acr~, ~acr/short~, ~acr/long~, and ~acr/full~.
The ~acr~ links is the primary link type, this will expand to the full form the first time the acronym is written, otherwise it will be printed as the acronym.
This removes the need of tracking where you first used an acronym when you edit your draft.
The other link types will always print the short, long, or full forms respectively.
For the acronym "GUI", the short form is the acronym itself "GUI", the long form is written out "Graphical User Interface", and the full form is the definition of the acronym "Graphical User Interface (GUI)."

To use acronyms, they must be defined user Org keywords in the form ~key:short:long~, where ~key~ is what is used to identify the acronym in the links.
As a full example:

#+begin_src org
  ,#+OMNIX_ACRONYM: gui:GUI:Graphical User Interface
  ,#+OMNIX_ACRONYM: tui:TUI:Text User Interface
  ,#+OMNIX_ACRONYM: cli:CLI:Command-Line Interface

  The application's behavior can be modified by passing arguments to the [[acr:cli]] (expands to full form) or by configuration with its [[acr:gui]] (also expands to full form).
  When using the [[acr:cli]] (expands to "CLI"), ...
  As opposed to a [[acr:gui]], a [[acr/long:tui]] (expands to "Text User Interface")...
#+end_src

Note: Acronym must be defined one per keyword.

This module currently has three processors, ~plain~, ~link~, and ~gls~.
The ~link~ processor will link later ~[[acr:key]]~ links to the first use (i.e. the definition).
It only creates hyperlinks for the ~acr~ links.
This can be used with any backend that has hyperlink functions defined for it in the ~omnix-hyperlink.el~ file.

The ~gls~ processor defers acronym management to the ~glossaries~ package and therefore only works with LaTeX derived backends.
* Text coloring
Color links allow coloring text for different backends.
This adds the ~xcolor~ package as a dependency for LaTeX backends.
Naturally, text coloring does not work with plain text backends.
For those a fallback method is used based on the format string in ~omnix-color-fallback~.
This uses a special format string where ~%s~ will be replaced with the link description and ~%c~ will be replaced with the color name (not the color code).
Either format argument can be omitted.

Basic usage:

#+begin_src org
  [[color:red][An important message]]
#+end_src

Colors can be defined in the header with keyword ~#+OMNIX_COLOR: blue:#0071BC~ or globally in the ~omnix-color-alist~.
Currently only HTML color codes are supported.

If a color that has not be defined is used, that color will be passed as is to the backend.
For example, assuming blue is defined as above, ~[[color:blue][Some colorful text]]~ will be passed to HTML as ~<a style="color:#0071BC;">Some colorful text</a>~ whereas if "red" has not been defined the previous example would be transcoded to ~<a style="color:red;">An important message</a>~ allowing the use of predefined colors (but note the potential of backends not have the same list of predefined colors).

* Sansext links
The ~sansext~ links are transformed into regular ~file~ links after replacing the path's extension with the backend preferred extension (as defined in ~omnix-sansext-extension-alist~).
These links are intended to be used with images, and likely images that are pragmatically generated, to dynamically select the best image type for the backend.
By default, LaTeX will use PDFs, HTML (and derived backends including markdown) will use SVGs, and everything else uses PNGs.
No attempt at being clever in the selection process is made, the links are blindly converted, if there is no file with the selected extension the export fail.

As an example, if this PNG ~sansext~ link is in the Org file ~[[sansext:lines.png]]~, it will be translated to ~[[file:lines.pdf]]~ when exporting to PDF and to ~[[file:lines.svg]]~ when exporting to HTML.
(Note the extension is optional ~[[sansext:lines]]~ would work as well.)
See the ~tests/Makefile~ for an example of a ~make~ recipe that ensures the output is dependent on the generation of the right figures.

* Extending
Whenever a module uses processors, users can create new processors with the ~omnix-*-create-processor~ functions.
Those can then be added to the relevant processor alist.
Processors are plists with at a minimum a name and an optional backend list when it is specific to one or more backends and an optional setup function (see ~omnix--processors.el~ for more information on the generic processor interface).

Modules will extend that interface to require a set of functions for performing specific tasks.
Often this will mean a function per link that is handled.
See the creation functions help for the exact functions required.
